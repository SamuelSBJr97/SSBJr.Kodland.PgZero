sequenceDiagram
    participant GameStart as "Game / Runner"
    participant Generator as "Generator"
    participant RoomManager as "RoomManager"
    participant Grid as "Grid / Cells"
    participant Player as "Player"
    participant BugA as "Bug A"
    participant BugB as "Bug B"
    participant BugC as "Bug C"
    participant Collision as "CollisionSystem"

    Note over GameStart,Generator: 1) Início da geração procedural (5 salas)

    GameStart->>Generator: requestGenerateDungeon(seed?)
    Generator->>RoomManager: createRooms(5)
    RoomManager->>RoomManager: allocateRoomSlots(R1..R5)

    Note over RoomManager,Grid: 2) Para cada sala: criar Grid de células (tile-based floor)
    RoomManager->>Grid: initGrid(roomId, rows, cols)
    Grid-->>RoomManager: gridWithCells(roomId)
    Note over Grid: cada célula = walkable/non-walkable

    Note over Generator: 3) Esculpir chão, portas e corredores (incluindo bifurcações)
    Generator->>RoomManager: carveFloor(roomId, cells)
    Generator->>RoomManager: placeDoorsAndCorridors(connections)
    RoomManager-->>RoomManager: ensureConnectivity(graph)  %% verifica que todas as salas são alcançáveis

    Note over RoomManager: 4) Criar ligações (ex.: R1->R2, R1->R3 (fork), R2->R4, R3->R4, R3->R5)
    RoomManager->>RoomManager: createLink(R1,R2)
    RoomManager->>RoomManager: createLink(R1,R3)
    RoomManager->>RoomManager: createLink(R2,R4)
    RoomManager->>RoomManager: createLink(R3,R4)
    RoomManager->>RoomManager: createLink(R3,R5)

    Note over GameStart,RoomManager: 5) Spawn do jogador e de 3 bugs
    GameStart->>RoomManager: spawnEntity(Player, R1, cell(x1,y1))
    RoomManager-->>Player: placedAt(R1, cell(x1,y1))
    GameStart->>RoomManager: spawnEntity(BugA, R2, cell(x2,y2))
    GameStart->>RoomManager: spawnEntity(BugB, R3, cell(x3,y3))
    GameStart->>RoomManager: spawnEntity(BugC, R4, cell(x4,y4))

    Note over Player,BugA,BugB,BugC: 6) Movimento baseado em células usando o Grid
    Player->>Grid: requestPath(currentCell, targetCell)
    Grid-->>Player: path(listOfCells)
    Player->>Player: stepTo(nextCell) / updatePosition
    Player->>RoomManager: onEnterDoor(doorCell) if crossing rooms

    BugA->>Grid: computePatrolPath(pattern)
    Grid-->>BugA: path(listOfCells)
    BugA->>BugA: stepTo(nextCell)

    BugB->>Grid: computeWander()
    Grid-->>BugB: nextCell
    BugB->>BugB: stepTo(nextCell)

    BugC->>Grid: chaseIfSee(playerCell)
    Grid-->>BugC: pathTo(playerCell) or nextCell
    BugC->>BugC: stepTo(nextCell)

    Note over Collision: 7) Detecção de colisões e interações
    Player->>Collision: checkCollision(nextCell)
    BugA->>Collision: checkCollision(nextCell)
    Collision-->>Player: collisionResult
    Collision-->>BugA: collisionResult

    Note over RoomManager,Generator: 8) Exportar grafo de conectividade para pathfinding entre salas
    RoomManager->>Generator: exportConnectivityGraph()
    Generator-->>GameStart: dungeonReady()

    Note over GameStart,Player: 9) Jogo começa — loop de atualização (player + bugs)
    GameStart->>Player: update(dt)
    GameStart->>BugA: update(dt)
    GameStart->>BugB: update(dt)
    GameStart->>BugC: update(dt)
